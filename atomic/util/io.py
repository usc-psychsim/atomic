import argparse
import gzip
import json
import logging
import os
import pickle
import re
import shutil
import tempfile
import zipfile
from enum import IntEnum

__author__ = 'Pedro Sequeira'
__email__ = 'pedro.sequeira@sri.com'


def get_file_changed_extension(file, ext):
    """
    Changes the extension of the given file.
    :param str file: the path to the file.
    :param str ext: the new file extension.
    :rtype: str
    :return: the file path with the new extension.
    """
    return os.path.join(os.path.dirname(file),
                        '{}.{}'.format(get_file_name_without_extension(file), ext.replace('.', '')))


def get_file_name_without_extension(file):
    """
    Gets the file name in the given path without extension.
    :param str file: the path to the file.
    :rtype: str
    :return: the file name in the given path without extension.
    """
    file = os.path.basename(file)
    return file.replace(os.path.splitext(file)[-1], '')


def get_files_with_extension(path, extension, sort=True):
    """
    Gets all files in the given directory with a given extension.
    :param str path: the directory from which to retrieve the files.
    :param str extension: the extension of the files to be retrieved.
    :param bool sort: whether to sort list of files based on file name.
    :rtype: list[str]
    :return: the list of files in the given directory with the required extension.
    """
    file_list = [os.path.join(path, f) for f in os.listdir(path) if f.endswith('.' + extension)]
    if sort:
        file_list.sort()
    return file_list


def get_directory_name(path):
    """
    Gets the directory name in the given path.
    :param str path: the path (can be a file).
    :rtype: str
    :return: the directory name in the given path.
    """
    return os.path.basename(os.path.dirname(path))


def create_clear_dir(path, clear=False):
    """
    Creates a directory in the given path. If it exists, optionally clears the directory.
    :param str path: the path to the directory to create/clear.
    :param bool clear: whether to clear the directory if it exists.
    :return:
    """
    if clear and os.path.exists(path):
        shutil.rmtree(path)
    if not os.path.exists(path):
        os.makedirs(path)


def delete_file(file):
    """
    Deletes the file in the given path if it exists.
    :param str file: the path to the file to be deleted.
    :return:
    """
    if os.path.exists(file):
        os.remove(file)


def change_log_handler(log_file, verbosity=1, fmt='[%(asctime)s %(levelname)s] %(message)s'):
    """
    Changes logger to use the given file.
    :param str log_file: the path to the intended log file.
    :param int verbosity: the level of verbosity, the higher the more severe messages will be logged.
    :param str fmt: the formatting string for the messages.
    :return:
    """
    log = logging.getLogger()
    for handler in log.handlers[:]:
        log.removeHandler(handler)
    file_handler = logging.FileHandler(log_file, 'w')
    formatter = logging.Formatter(fmt)
    file_handler.setFormatter(formatter)
    log.addHandler(file_handler)
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    log.addHandler(stream_handler)
    log.level = logging.WARN if verbosity == 0 else logging.INFO if verbosity == 1 else logging.DEBUG


def save_args(args, file_path):
    """
    Saves the given `argparse` arguments to a json file.
    :param Namespace args: the arguments generated by `argparse` to save.
    :param str file_path: the path to the json file where to save the arguments.
    """
    args_dict = vars(args)
    args_dict = {k: v.name if isinstance(v, IntEnum) else v for k, v in args_dict.items()}
    save_dict_json(args_dict, file_path)


def save_dict_json(dictionary, file_path):
    """
    Saves the given dictionary to a json file.
    :param dict dictionary: the dictionary to save.
    :param str file_path: the path to the json file where to save the dictionary.
    """
    with open(file_path, 'w') as fp:
        json.dump(dictionary, fp, indent=4)


def save_object(obj, file_path, compress_gzip=True):
    """
    Saves a binary file containing the given data.
    :param obj: the object to be saved.
    :param str file_path: the path of the file in which to save the data.
    :param bool compress_gzip: whether to gzip the output file.
    """
    with gzip.open(file_path, 'wb') if compress_gzip else open(file_path, 'wb') as file:
        pickle.dump(obj, file, protocol=pickle.HIGHEST_PROTOCOL)


def load_object(file_path):
    """
    Loads an object from the given file, possibly gzip compressed.
    :param str file_path: the path to the file containing the data to be loaded.
    :return: the data loaded from the file.
    """
    try:
        with gzip.open(file_path, 'rb') as file:
            return pickle.load(file)
    except OSError:
        with open(file_path, 'rb') as file:
            return pickle.load(file)


def compress_files(input_files, file_path, keep_structure=True):
    """
    Creates a zip compressed file containing the provided input files.
    :param list[str] input_files: a list with the paths to the input files to be compressed.
    :param str file_path: the path to the output zip archive containing the compressed files.
    :param bool keep_structure: whether to keep the same directory structure of the input files in the zip archive. If
    `False`, then files will all be saved at the root level inside the archive, with directory structure used to rename
    the files, e.g., `path/to/file.txt` will be saved as `path_to_file.txt`.
    """
    with zipfile.ZipFile(file_path, mode='w') as zf:
        for input_file in input_files:
            file_name = input_file if keep_structure else re.sub(r'[\\|/]', '_', input_file)
            zf.write(input_file, file_name, compress_type=zipfile.ZIP_DEFLATED)


def extract_files(file_path, output_dir=None):
    """
    Extracts files from a compressed zip archive.
    :param str file_path: the path to the input zip archive containing the compressed files.
    :param str or None output_dir: the path to the directory in which to extract the files. If `None`, files will be
    extracted to a temporary directory.
    :rtype: str
    :return: the path to the directory into which the files were extracted.
    """
    if output_dir is None:
        output_dir = tempfile.TemporaryDirectory().name
    with zipfile.ZipFile(file_path, mode='r') as zf:
        zf.extractall(str(output_dir))
    return output_dir


def str2bool(v: str) -> bool:
    """
    Converts the given string parsed using `argparse` to a boolean value.
    :param str v: the argument value to be converted.
    :rtype:bool
    :return: the boolean value corresponding to the given argument.
    """
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')
